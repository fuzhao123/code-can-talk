<!-- TOC -->

- [1. 前言](#1-前言)
- [2. 第一章 劣质代码带来的劣质体验](#2-第一章-劣质代码带来的劣质体验)
    - [2.1. 命名类问题](#21-命名类问题)
        - [2.1.1. 没有考虑调用时的情形](#211-没有考虑调用时的情形)
        - [2.1.2. 命名用词不当](#212-命名用词不当)
        - [2.1.3. 否定式命名](#213-否定式命名)
    - [2.2. 结构类问题](#22-结构类问题)
        - [2.2.1. switch-case 引起的长分支](#221-switch-case-引起的长分支)
        - [2.2.2. 莫名其妙的default](#222-莫名其妙的default)
        - [2.2.3. 不必要的Guard代码](#223-不必要的guard代码)
        - [2.2.4. 嵌套过深](#224-嵌套过深)
- [3. 第二章 劣质代码是怎么产生的](#3-第二章-劣质代码是怎么产生的)
    - [3.1. 定式思维](#31-定式思维)
    - [3.2. 认为状态只有采用整数定义](#32-认为状态只有采用整数定义)
    - [3.3. 对设计方法不了解](#33-对设计方法不了解)
    - [3.4. 编程习惯不佳](#34-编程习惯不佳)
        - [3.4.1. 没有管理好代码的职责](#341-没有管理好代码的职责)
- [4. 第六章 编程语言的学习](#4-第六章-编程语言的学习)
    - [4.1. 简化的校验模型](#41-简化的校验模型)
    - [4.2. 简化的权限模型](#42-简化的权限模型)
- [5. 第7章 设计方法的学习](#5-第7章-设计方法的学习)
    - [5.1. 设计模式](#51-设计模式)
    - [5.2. 采用位掩码减少类的个数](#52-采用位掩码减少类的个数)
        - [5.2.1. 位掩码](#521-位掩码)
        - [替代多态](#替代多态)
        - [替代多态枚举](#替代多态枚举)
- [第 9 章 编程习惯的改进](#第-9-章-编程习惯的改进)
    - [结构方面的改进](#结构方面的改进)
        - [缩短长判定](#缩短长判定)
        - [缩短长分支](#缩短长分支)
        - [减少参数个数](#减少参数个数)
        - [减少嵌套的层数](#减少嵌套的层数)
    - [分离暧昧关系](#分离暧昧关系)
        - [循环引用](#循环引用)
        - [间接继承](#间接继承)
    - [多维度变化](#多维度变化)
    - [自相似对象](#自相似对象)
- [6. 其他](#6-其他)
    - [6.1. 随机提供器](#61-随机提供器)
    - [在旧代码基础上扩展类似功能](#在旧代码基础上扩展类似功能)

<!-- /TOC -->
# 1. 前言

比较糟糕的代码的写法比如:

```java
scene.find(hero, enemy, Kongfu.FIST);//都不知道谁打了谁
```

普通方式书写的代码:

```java
hero.fight(enemey, Kongfu.FIST);//知道代码的意思,但是阅读体验还不够好
```

而自表达的方式书写的代码如

```java
hero.fight(enemy).with("FIST)";//如果不看那些符号,读起来就是一句话
```

-----------


# 2. 第一章 劣质代码带来的劣质体验

在阅读书写不够精良的代码时,读者的行为基本能够反映出代码存在的问题:

- 一直滚动鼠标滚轮 -- 方法过长
- 总是全局搜索 -- 方法过长
- 反复地查看方法实现 -- 命名无法反映其真实含义
- 不停地查看调用方法实现 -- 调用层数太多
- 画流程图 -- 嵌套太深

> 嗯 理解框架的时候, 遇到了某些方法难于理解的时候, 不妨往上面思考, 是本身你的能力不足以理解还是它本身写的就有问题.

## 2.1. 命名类问题

### 2.1.1. 没有考虑调用时的情形

如果要建立一个班级(Grade)类,那么获得学生数量该用下面哪种命名呢?

```java
//不理想的实现
grade.getStudentsCount(); // 这个get有些多余
grade.countStudents(); // 这是一个行为,给人一种"需要时间"计算出来的感受
grade.students.size(); // 这样比较不容易理解, 但是书写最简单,图省事而直接把students属性公开并不是一种好的做法
grade.size(); // 有被误解为"班级的房间大小"的可能

//完美地实现
grade.studentsCount(); // 能够最直接地反映这个要求

```

### 2.1.2. 命名用词不当

- research 不能表示重新检索, 应该用searchAgain
- limit 表示极限而不是限制, restriction或者constraint才表示限制
- fasten 表示固定而不是加速, 应该用accelerate

> 英语没学好....

### 2.1.3. 否定式命名

有个变量`hardKeyboardHidden`表示没有接入硬键盘.那么,在判定软键盘是否显示时,条件判定式写成这样:

```java
if (hardKeyboardHidden == 0) return false;
```

估计读起来得费上一会儿功夫才能够理解吧
```java
if (hardKeyboard.isConnected())
```
就没有那么多疑惑了
当然,这需要整体框架的调整才能够实现.


## 2.2. 结构类问题

### 2.2.1. switch-case 引起的长分支

```java
    public boolean onKeyDown(int keyCode, KeyEvent event){
        switch (keyCode){
            case KeyEvent.KEYCODE_ENTER :
                break;
            case KeyEvent.KEYCODE_SPACE :
                break;
            case KeyEvent.KEYCODE_LEFT :
                break;
            case KeyEvent.KEYCODE_RIGHT :
                break;
            case KeyEvent.KEYCODE_UP :
                break;
            case KeyEvent.KEYCODE_DOWN :
                break;
            case KeyEvent.KEYCODE_BUTTON_1 :
                break;
            case KeyEvent.KEYCODE_BUTTON_2 :
                break;
            case KeyEvent.KEYCODE_BUTTON_3 :
                break;
            case KeyEvent.KEYCODE_BUTTON_4 :
                break;
            ......

            return false;

        }
    }

```

其实这些案件都有一定的规律可循,如果按照规律来换分按键的话,代码就会简练得多.

```java
    public boolean onKeyDown(int keyCode, KeyEvent event){
        if (event.isPrintintKey()){
            return appendInput(keyCode);
        }else if (isArrowKey(keyCode)){
            return moveCursor(keyCode);
        }else if (isChannelKey(keyCode)){
            return appendInput(convertChannelToNumber(keyCode));
        }else  if (isFunctionKey(keyCode)){
            return processFuntionalKey(keyCode);
        }
        
        return false;
    }

```

这样,通过简化上层处理,把各种处理逻辑分散到各个小的方法中完成,对可读性的改善效果是很明显的.

### 2.2.2. 莫名其妙的default

在switch-case中,default语句代表没有被列出的case的处理.但是对于有限取值范围的情形,在列出所有的case之后,还有多列一个超出取值范围的default.遇到这种情况的程序员由于无法确定default应该怎么处理,一般采取直接return返回.但是对于需要返回值的方法来说,return 0;或者return false;都是可能引发错误的处理方式.

```java
   public enum State{
        CREATED, UPDATED, DELETED;
    }
    
    public void process(State state){
        switch (state){
            case CREATED:
                break;
            case UPDATED:
                break;
            case DELETED:
                break;
            default://这个分支永远不会发生
                break;
        }
    }

```

这种情况可以利用多态方式来处理,下面的例子采用了枚举,也可以用接口派生的方法.

```java
   public enum State{
        CREATED{
            public void process(){
                
            }
        },
        UPDATED{
            public void process(){

            }
        },
        DELETED{
            public void process(){

            }
        };

    } 
    
    public void process(State state){
        state.process();
    }

```
这样由于State的取值范围有限,不会出现其他情况.所以,就不必考虑default的情形了.



### 2.2.3. 不必要的Guard代码

一般来说,为了防止传入的参数是null, 采取Guard代码防止NullPointException异常发生是一种常见的做法.但是如果可以确保传入的参数不是null,则没必要进行校验.对于长度的校验也是一样的.

```java

public void process(Object object){
    if (object == nul){
        return;
    }

    //process......
}
```

上面的代码可以简化为下面这样来避免使用null判定:

```java
Object object = ObjectFactory.create();
process(object);
```

在工厂类ObjectFatory中确保object不为null;

> 概括起来就是调用的上层已经做好处理,下层直接用就好,不需要考虑其他德尔条件, 不增加负担

### 2.2.4. 嵌套过深

```java

    public void render(){
        for (int i = 0; i < MAX_ROW; i++) {
            for (int j = 0; j < MAX_COLUM; j++) {
                if (balls[i][j].state != DESTROYED){
                    if (balls[i][j].state == SELECTED){
                        Color color = getLightColor(balls[i][j].color);
                        display(i, j, color);
                    } else {
                        Color color = getColor(balls[i][j].color);
                        display(i, j, color);
                    }
                }
            }
        }
    } 

```

当代码嵌套这么深时,理解代码就变得不容易了.对于上述例子如果把balls的二维数组改成一维数组,然后把状态作为Ball类的一个属性,嵌套就会一下子减少很多层.例如

```java
    public void process(){
        for (Ball ball : balls){
            ball.render();
        }
    }
    
    public class Ball{
        public int x;
        public int y;
        public State state;
        public Color lightColor;
        public Color darkColor;
        public void render(){
            state.render(this);
        }
        
        public enum State{
            DESTROYED{
              public void render(Ball ball){
                  
              }  
            },
            SELECTED{
                public void render(Ball ball){
                    display(ball.x, ball.y, ball.lightColor);
                }
            },
            NORMAL{
                public void render(Ball ball){
                    display(ball.x, ball.y, ball.darkColor);
                }
            };
            
            public void render(Ball ball){
                
            }
        }
    }

```


# 3. 第二章 劣质代码是怎么产生的


## 3.1. 定式思维

例如,格斗游戏中, 单击`轻拳`按钮,在不同的情况下所展示的图像会不同.一般会倾向于按照这种结构来实现代码.

```java
public class Warrior{
    public void fight(){
        if (条件1){
            //处理1
        } else if (条件2){
            //处理2
        } else if (条件3){
            //处理3
        }
        
    }
}
 
 
```

但是,对于这种情况来说,将`轻拳`采用多态来处理,根据情况通过Factory创建不同的`轻拳`对象,从而进行攻击处理的话,代码就变得更为易读,易懂且容易扩展了.

```java

    public class Warrior{
        public Attackable fist;
        public void fight(){
            FistFactory.create().attack();
        }
    }
    
    public interface Attackable{
        public void attack();
    } 
    
    publicic class LightFist implements Attackable{

        @Override
        public void attack() {
            //处理1
        }
    }

    publicic class SuperLightFist implements Attackable{

        @Override
        public void attack() {
            //处理2
        }
    }

    publicic class LiteFist implements Attackable{

        @Override
        public void attack() {
            //处理3
        }
    }
    
    public class FistFactory{
        public static Attackable create(){
            if (条件1){
                return new LightFist();
            }else if (条件2){
                return new SuperLightFist();
            }else if (条件3){
                return new LightFist();
            }
            return null;
        }
    }
```

当需要增加一个新的攻击方式时,只要对上述Attackable接口进行实现,并且FistFactory类中进行注册即可.而从阅读上来说,上层代码并不需要关心当前的是哪个攻击对象,只要调用其方法attack即可.

## 3.2. 认为状态只有采用整数定义

例如,下面的例子中,1代表刚注册, 2代表已经申请成功,3代表其他状态,那么在申请时的处理如下:

```java

public void apply(){
        if (state == 1){
            state = 2;
            message = "申请成功.";
        } else if (state == 2){
            message = "你已经申请过了.";
        } else {
            message = "你还没有资格申请.";
        }
    }
```

这样的代码,即使把魔法数字变为常量,对改良可读性的帮助也是有限的.但是,如果采用状态模式来处理,就会变得简单,并且具有更好的可扩展性.

```java

   public interface State{
        public State apply() throws BusinessException;
    }
    
    public class Registered implements State{

        @Override
        public State apply() throws BusinessException {
            return new Applied();
        }
    }

    public class Applied implements State{

        @Override
        public State apply() throws BusinessException {
            return new BusinessException("你已经申请过了.");
        }
    }

    public class Passed implements State{

        @Override
        public State apply() throws BusinessException {
            return new BusinessException("你还没有资格申请.");
        }
    }
    
    public void apply(){
        try {
            state = state.apply();
        } catch (BusinessException e){
            showMessage(e.getMessage());
        }
    }
```

## 3.3. 对设计方法不了解

由于任务划分等管理方面的原因,程序员被定位为依照别人的设计进行代码加工的"码农",以至于程序员很少能够思考设计方面的事情,只是机械的堆砌代码.在这样 的任务分配模式下,程序员的能力得不到提升,也就不知道更多好的设计方法,而对设计方法的不了解会造成很多代码上的问题.

下面是一些常见的对于设计方法不了解而造成的问题: 
- 重复与类似
- 包结构不清晰
- 类责任不明确
- 常量数据类
- 长方法
- 复杂分支
- 类膨胀
- 类爆炸

不了解设计方法会在一个简单的问题上耗费大量的时间,有时会把一个简单的问题复杂化,有时会重复实现已有完整解决方案的代码,有时则会埋下bug隐患.

> 那么问题来了, 框架的设计方法该如何了解透彻,从何入手?

## 3.4. 编程习惯不佳

### 3.4.1. 没有管理好代码的职责

比如在一个等级用户信息的应用程序中需要进行电子邮件的校验,那么对于电子邮件校验的代码,如果不注意就会直接放在UI代码中.然而,这个电子邮件的校验程序可能在别的地方调用,那么就无法访问这个方法了.为了提高可重用性,可以把这个方法放在Util类里面,放在Util类里的调用情形是这样的:

```java
Util.isEmail(user.email);
```

这仍然不够好,因为在上面的代码中, email是String 类型.当需要发送电子邮件时需要将电子邮件地址携程"姓名"<邮件地址>的形式.单纯的String
类型不能满足要求.也就是说, 需要一个EmailAddress类来存储与电子邮件地址相关的数据.

```java

public class EmailAddress{
    String address;
    String name;
}

```

我们可以得出结论: 电子邮件的格式校验应该放在电子邮件类中实现.

```java

public class EmailAddress{
    String address;
    String name;

    public boolean verify(){
        //方法体略.
    }
}
```

这个例子说明了随手放置方法功能会导致代码可复用性降低,职责混乱等问题.


# 4. 第六章 编程语言的学习

## 4.1. 简化的校验模型

当从外部输入传来输入时要对响应的数据进行校验才能够使用.但是传统方法把所有参数都进行全面校验,光校验代码就会占据一半个方法的长度.下面是一个图书信息保存的例子:

```java

    public  class BookAction{
        public void save(Book book) throws ValidationError{
            if (book.name == null || book.name.equals("")){
                throw new ValidationError("书名不能为空.");
            }
            if (book.isbn == null || book.isbn.equals("")){
                throw new ValidationError("ISBN不能为空.");
            }
            if (book.press == null || book.press.equals("")){
                throw new ValidationError("出版社不能为空.");
            }
            if (book.author == null || book.author.equals("")){
                throw new ValidationError("作者不能为空.");
            }
            
            book.save();
        }
    }
```

为了更加明确代码的含义,附上Book类的定义和ValidationException类的定义

```java
    public class Book{
        public String name;
        public String author;
        public String press;
        public String isbn;
        
    }
    
    public class ValidationError implements Throwable{
        public String mMessage;
        public ValidationError(String message){
            mMessage = message;
        }
    }

```

就上述代码来说,大量的校验代码使得阅读体验大大下降.
有一种相对简单的修改方式就是将非空判定提取到Util类中完成.

例如

```java
public class StringUtil{
        public static boolean isNullOrEmpty(String text){
            return text == null || text.equals("");
        }
    }
```
但是这并不能够缩减长长的判定语句,而且如果增加了长度校验,类型校验(例如ISBN号只能是数字和短线,并符合一定规则)等,校验代码将仍然会变长

如果采用这种形式来书写,代码的可读性就一定能大大提高
```java
    public class BookAction{
        public void save(Book book){
            List<ValidateError> errors = validate(book);
            if (!errors.isEmpty()){
                render(errors);
                return;
            }
            book.save();
        }
        
        private List<ValidateError> validate(Entity entity){
            //这里究竟该怎么写呢?后面再来分析
        }
        
        private void render(List<ValidateError> errors){
            //将各种错误消息显示在正确的位置上
        }
    }
    
    public class ValidateError{
        public String fieldName;
        public String errorText;
    }
```

如果只是把以前的校验换一种形式存放,那么并不能对整体可读性带来多大优势,而且可复用性也不强.所以,校验应该和Book类本身分开, 将来校验其他对象时也可以采用同样机制进行校验.

如果可以通过这种形式对Book进行定义,其他对象也可以采用同样方式进行定义,代码就变得易读好懂,复用性也得到了提高

```java
 public class Book extends Entity{
        @Required
        public String name;
        @Required
        public String author;
        @Required
        public String press;
        @Required
        @MaxLength(17)
        public String isbn;
    }
```

上述Annotaion的对应定义如下:
```java
    public @interface Required{

    }

    public @interface MaxLength{
        int value();
    }

```
那么怎么才能实现对应的校验呢?
限于篇幅原因,下列代码为简化校验模型,只处理String类型的数据,处理其他类型的数据则会发生错误.


```java
    public class BookAction {
        public List<ValidateError> validate(Book book) {
            List<ValidateError> errors = new ArrayList<>();
            java.lang.reflect.Field[] fields = book.getClass().getDeclaredFields();
            for (java.lang.reflect.Field field : fields) {
                Annotation[] annotaions = field.getDeclaredAnnotations();
                for (Annotation a : annotaions) {
                    if (a instanceof Required) {
                        if (ValidateUtil.isNullOrEmpty(field)) {
                            errors.add(new ValidateError(field, field.name + "不能为空."));
                        }
                    } else if (a instanceof MaxLength) {
                        if (field.length() > ((MaxLength) a).value()) {
                            errors.add(new ValidateError(field, field.name + "长度不能超过" + ((MaxLength) a).value() + "."));
                        }
                    }
                }
            }

            return errors;
        }
    }

```

这样,就可以通过Annotation来大幅度简化校验代码,并且通过一个通用的校验来进行全部的处理.还可以考虑为校验机制增加可扩展接口,为方便其他人增加自己的校验机制,例如特殊的格式校验等.

## 4.2. 简化的权限模型

权限校验是一般系统中比较常见的一个功能.对于权限设计的方法也是多种多样的,而采用注解进行权限模型的设计会使实现和变更都变得很容易.

页面的权限声明方式:

```java

 public class Users extends Controller{
       @Permission(Authority.ALL)
       public String list(){}

       @Permission(Authority.ADMIN | Authority.SELF)
       public String edit(int id){}

       @Permission(Authority.ADMIN | Authority.SELF)
       public String save(int id){}
   }
```

这是一个[以位掩码的方式](#采用位掩码减少类的个数)定义的类,
而使用这些数据的方式可以通过下面的类来实现
```java
    public class Authority{
        public static final int ALL = 0xffffff;

        public static final int ROLE_MASK = 0x000fff;
        public static final int ADMIN = 0x000001;
        public static final int MANAGER = 0x000002;

        public static final int OWNER_SHIP = 0xfff000;
        public static final int SELF = 0x001000;
        public static final int OWNER = 0x002000;
    }


    public class Controller{
        public String invoke(String className, String methodName){
            Class clazz = Class.forName(className);
            Method method = clazz.getDeclaredMethod(methodName);
            Annotation permission = method.getDeclaredMethod("Permession");
            int authority = permission.value();
            int userPermission = session.get("USER_PERMISSION");
            if ((userPermission && Authority.ROLE_MASK & authority == 0)
                    && (userPermission & Authority.OWNER_SHIP & authority == 0)){
                return "no_permission";
            }
            
            return method.invoke(clazz.newInstance());
        }
    }
```

在上面的例子中,主调度方法利用各个方法定义的注解来判定其权限,这样每个方法定义其自己的权限即可.通过这样的方法把权限分散到各个方法自身去,比较容易判断定义的正确性,也利于维护,而采用集中式权限判定容易产生遗漏和错误.

# 5. 第7章 设计方法的学习


## 5.1. 设计模式

- 创建型模式:
  - 抽象工厂:创建几类家族的实例
  - 构建者:把对象的构建和它分开
  - 工厂方法:创建一个共通接口的若干个子类的实例
  - 原型:创建一个被完整初始化的实例用于复制或者克隆
  - 单例:使一个类无论在什么时候访问都可以得到唯一的实例
- 结构性模式:
  - 适配器:为多个不同的类之间建立连接的接口
  - 桥接:对象有多个属性时把属性之间的关联关系从m*n改为m+n
  - 装饰:动态的为对象增加责任
  - 外观:通过一个接口来隐藏整个子系统
  - 享元:用一个共享的实例来加快访问
  - 代理:用一个对象代表另一个对象
- 行为型模式:
  - 职责链:在一个链条间传递任务
  - 命令:把命令包装为对象
  - 翻译者:在一个语言环境中不同的语言元素表示不同的语义
  - 迭代者:循环地访问一个列表中的元素
  - 协调者:在对象之间建立一个简化的沟通类
  - 备注:存储对象内部的数值
  - 观察值:当对象发生变化时通知一组其他对象
  - 状态:当对象的状态变更时变更处理
  - 策略:采取不同的算法进行不同的处理
  - 模板方法:把通用的处理放在父类,具体的实现步骤放在子类中实现
  - 访问者:不必改变对象定义的情况下定义应用于对象的操作

## 5.2. 采用位掩码减少类的个数

### 5.2.1. 位掩码

位掩码的意思是,对于一个数字的每一位作为一个开关的标志.当若干个位在一起时,可以表征的状态就达到2的
n次方之多.如果同样的组合都写成类,那么累的数量就会急剧上升.位掩码是一个很好地减少类数量的方法.位掩码可以用来管理多种不同维度的变化.例如:


```java
public static final int BIT_MASK_COLOR = 0x00f;
public static final int BIT_MASK_SHAPE = 0xff0;

public static final int COLOR_RED = 0x001;
public static final int COLOR_GREEN = 0x002;
public static final int COLOR_YELLOW = 0x003;

public static final int SHAPE_RECTANGLE = 0x010;
public static final int SHAPE_CIRCLE = 0x020;
public static final int SHAPE_TRIANGLE = 0x040;
public static final int SHAPE_ELLIPSE = 0x080;


```

就上述组合来说,红色矩形的值为0x011,绿色三角形为0x022.

对于位掩码的运算是通过或运算`|`来将多种位掩码组合在一起的,而通过与运算`&`来计算其中对应的位是ON 还是 OFF.

就上述例子来说,获得一个物体的颜色用object & MASK_COLOR;
获取一个物体的形状,用object & MACK_SHAPE;
判定颜色是否为绿色, 则用if(object & COLOR_GREEN == COLOR_GREEN){}


### 替代多态

有时采用多态会产生大量的类,而采用位掩码则可以在一个类中完成等价的操作.

例如文本框的输入限制,文本框可以输入数字,电子邮件,电话号码,密码,时间,邮政地址,姓名,姓名拼写等不同内容.每种类型有涉及是否自动大小写.数字还涉及是否允许输入小数,是否允许输入符号.

试想一下,需要多少个类才能表征这些不同的状态?

下面是一些简单的尝试:

```java

    public class EditText{
        public AutoCaps autoCaps;
        public InputType inputType;
        enum AutoCaps{ CAPS_SENTENSE, CAPS_CHAR, CAPS_WORD}
    }
    
    public interface InputType{
        public char filterInput(char text);
    }
    
    public class Number implements InputType{

        @Override
        public char filterInput(char text) {
            return 0;
        }
    }

    public class Email implements InputType{

        @Override
        public char filterInput(char text) {
            return 0;
        }
    }
    
```
但是如果采用位掩码就相对简单得多.

```java  
    public class InputType{
        public static final int MASK_CONSTRAINT = 0x00fff;
        public static final int CONSTRAINT_NUMBER = 0x00001;
        public static final int CONSTRAINT_EMAIL = 0x00002;
        public static final int CONSTRAINT_PHONE = 0x00008;
        public static final int MASK_AUTO_CAPS = 0xff000;
        public static final int CAPS_SENTENSE = 0x01000;
        public static final int CAPS_WORD = 0x02000;
        public static final int CAPS_CHAR = 0x04000;
        
        public static final int MASK_NUMBER = 0xff000;
        public static final int SIGNED = 0x01000;
        public static final int DECIMAL = 0x02000;
    }
    

```


这样,只需一个类就可以实现该功能,并且由于许可长度足够长,还具有充分的可扩展性.Android的文本框属性就是采用这种方法设计的.实际上它支持的属性非常多,实现上也要比这个模型复杂得多.

同样,对于一个窗口来说,有标题栏,最大化按钮,最小化按钮,关闭按钮,图标,窗体外框,状态栏,工具栏,菜单栏等多种属性,也可以用位掩码的方式来实现.


### 替代多态枚举

有时候常量定义采用枚举,但是采用枚举之后的常量如果需要并列时,就要通过`||` 符号或者数组来定义,这会增加代码的长度以及判定的复杂度.例如:

```java
   public enum Authority{
        ADMINISTRATOR, MANAGER, OPERATOR;
    }
```
当角色有十多种时,判定一个页面是否有权限访问的处理会是这样的:
```java  
    if (permission == Authority.ADMINISTRATOR
       || permission == Authority.MANAGER
       || permission == Authority.OPERATOR){
        
    }
```
这样的代码需要到处写,会很麻烦.
另外一种方法是采用讲解,写成这样:

```java    
    
    @Permission(allowed == new Authority[]{
            Authority.ADMINISTRATOR, Authority.MANAGER
    });
```

对应上述注解的判定语句为:
```java
    Annotation permission = method.getDeclaredAnnotation("Permission");
    boolean allowed = false;
    for (Authority authority : permission.allowed){
        if (authority == user.permission){
            allowed = true;
            break;
        }
                
    }
    
    if (!allowed){
        return;
    }
```

而如果采用位掩码的形式就可以写成:
```java
    @Permission(Authority.ADMINISTRATOR | Authority.MANAGER)
```
调用时:
```java    
    Permission permission = method.getDeclaredAnnotation("Permission");
    if (user.permission & permission.value() == user.permission){
        
    }
```

相对来说,最后一种写法最为简练.

# 第 9 章 编程习惯的改进

## 结构方面的改进

### 缩短长判定

3. 去掉null判定 

很多时候,为了避免发生NullPointException,需要对对象进行非空判定.
然后,如果利用了空对象模式,这个判定就没有必要了.

例如: 在Android输入法中,当键盘启动时,处在一个不需要现实键盘的页面时,keyboard对象为空, 那么对于所有键盘的处理位置,都需要增加下面的判定

```java
if (keyboard == null){
    return;
}

```

下面就是一段例子代码:

```java

public class InputMethod extends InputMethodService{
    Keyboard mKeyboard;
    public void onCreate(){
        //根据情况,将mKeyboard初始化为SoftKeyBoard
        //或者HardKeyBoard实例,有时也不会生成
        //比如在插入硬盘启动到一个不可以输入的页面时
        
    }

    public boolean onKeyDown(int keyCode, KeyEvent event){
        if (mKeyboard == null){
            return;
        }
    }
}
```

但是,如果在初始化键盘时,根据情况将键盘生成为SoftKeyboard,HardKeyboard或者InvisibleKeyboard,则在调用键盘时就不必判定键盘是否为空.

```java
public class MyInputMethod extends InputMethodService{
    Keyboard mKeyboard;
    public void onCreate(){
        //如果不能初始化为SoftKeyboard或者HardKeyboard
        //则初始化为InvisibleKeyboard
    }

    public boolean onKeyDown(int keyCode, KeyEvent event){
        return mKeyboard.onKeyDown(keyCode, event);
    }
}


public interface Keyboard{
    public boolean onKeyDown(int keyCode, KeyEvent event);
}

public class SoftKeyboard implements Keyboard{
    public boolean onKeyDown(int keyCode, KeyEvent event){
        //具体软键盘处理
    }
}

public class HardKeyboard implements Keyboard{
    public boolean onKeyDown(int keyCode, KeyEvent event){
        //具体硬键盘处理
    }
}

public class InvisibleKeyboard implements Keyboard{
    public boolean onKeyDown(int keyCode, KeyEvent event){
        return false; // 直接将按键动作交给应用程序处理
    }
}

```

通过这样一个新的类,InvisibleKeyboard可以将诸多的if(mKeyboard == null) 的判定规避掉,从而降低代码的复杂度.


4. 状态模式 -- 减少判定的次数


对于复杂的判定条件,如何才能减少判定的层数呢?下面介绍一下状态模式.例如在输入程序中,根据候补显示状态的不同,按下返回键的处理也不同.

```java
public class Candidate{
    public int state;
    public int rowCount;
    public boolean visible;
    private static final int NORMAL_VIEW = 0;
    private static final int FULL_SCREEN = 1;
    private static final int CLOSED = 2;

    public boolean onKeyDown(int keyCode, KeyEvent event){
        if (keyCode == KeyEvent.KEYCODE_BACK){
            if (state == NORMAL_VIEW
                && rowCount == 1
                && visible == true){ // 只有一行候补时
                    visible = false;
                    state = CLOSED; // 关闭候补
            } else if (state == NORMAL_VIEW
                && rowCount > 1
                && visible == true){ // 有多行候补,但是只显示第一行时
                visible = false;
                state = CLOSED;
                    
            } else if (state == FULL_SCREEN){
                state = NORMAL_VIEW; // 返回单行显示
            } else if (state == CLOSED){
                MyInputMethod.getInstance().hideWindow();//关闭输入法
            }
        }
    }
}

```

其中,对于candidateView.state的判定如果改为状态模式,则整体代码的逻辑结构会变得简单.

```java
public class Candidate{
    public interface State{
        public State onKeyBack();
    }

    public State state;

    public boolean onKeyDown(int keyCode, KeyEvent event){
        if (keyCode == KeyEvent.KEYCODE_BACK){
            state = state.onKeyBack();
        }
    }
}

public class Normal implements Candidate.State{
    public State onKeyBack(){
        return new Closed(); // 关闭候补
    }
}

public class FullScreen implements Candidate.State{
    public State onKeyBack(){
        return new Normal(); // 单行显示
    }
}

public class Closed implements Candidate.State{
    public State onKeyBack(){
        MyInputMethod.getInstance().hideWindow(); // 关闭输入法
        return this;
    }
}

```

这样, 原本需要长分支才能够处理的onKeyDown中的BACK按键处理,分散到各个状态类中实现, 则onKeyDown方法中的BACK 按键处理变成了一句话.


### 缩短长分支

2. 策略模式

```java
对不同的按键进行分组, 创建一个接口 KeyProcessor;

public interface KeyProcessor {
    public boolean onKeyDown(int keyCode, KeyEvent event);
    public boolean onKeyUp(int keyCode, KeyEvent event);
}
```

然后创建几个处理器

```java

public ArrowKeyProcessor implements KeyProcessor{
    public boolean onKeyDown(int keyCode, KeyEvent event){
        // 处理方向键按下
    }

    public boolean onKeyUp(int keyCode, KeyEvent event){
        // 处理方向键抬起
    }
}


public ChannelKeyProcessor implements KeyProcessor{
    public boolean onKeyDown(int keyCode, KeyEvent event){
        // 处理方向键按下
    }

    public boolean onKeyUp(int keyCode, KeyEvent event){
        // 处理方向键抬起
    }
}
```

以此类推

这时, 在主体程序中, 根据按键的类型不同,采用不同的处理器进行按键处理,这样主体程序中的按键处理就会大幅度缩短.

```java
public class HardKeyboard{
    public boolean onKeyDown(int keyCode, KeyEvent event){
        if (event.isPrintingKey()){
            // 处理输入按键;
            return true;
        }

        try {
            KeyProcessor processor = 
             KeyProcessorFactory.createKeyProcessor(keyCode);
            processor.onKeyDown(keyCode, event);
            return true;
        } catch (Exception e){
            return false; // 发生Exception 表示不在处理范围内,交由App处理
        }
    }
}
```

实现主体代码之后, 在KeyProcesscorFactory中根据输入的KeyCode来生成对应的KeyProcessor对象.如果直接按照按键进行switch-case, 那么只是将代码复杂的问题转移了,并没有解决问题.

```java

public class KeyProcessorFactory{
    private static Map<Integer, String> 
        keyMaps = new HashMap<Integer, String>();
    static{
        keyMaps.put(KeyEvent.KEYCODE_DPAD_CENTER, "Enter");
        keyMaps.put(KeyEvent.KEYCODE_ENTER, "Enter");
        keyMaps.put(KeyEvent.KEYCODE_LEFT, "Arrow");
        keyMaps.put(keyEvent.KEYCODE_RIGHT, "Arrow");
    }

    public static KeyProcessor createKeyProcessor(int keyCode) throws ClassNotFoundException,
                    InstantiationException,
                    IllegalAccessException{
        String processorName = keyMaps.get(KeyEvent.KEYCODE_DPAD_CENTER);
        Class processor = 
            Class.forname("com.otrois.inputmethod.keyprocessor."
            + processorName
            + "KeyProcessor");
        return (KeyProcessor)processor.newInstance();
    }
}

```

这种手法将会大幅度缩减处理复杂度以及代码量, 但是会产生多个类.不过,还可以通过创建XML来管理各个按键的归属,从而进一步简化代码,并且让代码具有更高的可扩展性.

3. 去掉return 前的判定

先看下列代码: 

```java

public boolean hasMore(){
    if (list.size() > 0){
        return true;
    }
    return false;
}
```

这段代码的意图很明显, 当list中有元素时就返回true, 否则返回false.

这个方法只要返回的是boolean类型,编译就可以通过, 而boolean类型不仅仅是变量, 表达式也可以是boolean 类型, 为了能够更明确转换过程,先做一次中间转换.

```java
public class boolean hasMore(){
    if ((list.size() > 0) == true){
        return true;
    }
    return false;
}


```

如果把中间的表达式list.size() > 0 替换为一个变量a,那么上面的代码其实等价于

```java
public boolean hasMore(){
    return a;
}
```

在替换回来, 这段代码就可以写出:
```java
public boolean hasMore(){
    return list.size() > 0;
}
```

像这样, 可以通过用表达式代替变量的方式, 来减少一次判定.

### 减少参数个数

参数个数过多会导致: 1. 代码变复杂,受影响范围变大 2. 可读性降低,需要记忆各个参数

减少参数个数的方法有两种: 引入参数对象 与提取全局变量

1. 引入参数对象

例如, 一个计算器的功能

```java
public class Calculator{
    public int add(int a, int b){
        return a + b;
    }
}

public class Calculator{
    public int sub(int a, int b){
        return a - b;
    }
}

```

可见, 多个方法都采用了相同的参数类型, 即两个整数,其实可以合并一下;

```java
public class Calculator{
    public class Parameter{
        public int a;
        public int b;
    }

    public int add(Calculator.Parameter param){
        return param.a + param.b;
    }

    public int sub(Calculator.Parameter param){
        return param.a - param.b;
    }
}

```

其中, x,y,color 都可以提取为成员变量, 那么新的形式就是:

```java
public class Ball{
    int x, y, color;

    public void markHomeNeighbors(){
        
    }
}

```

### 减少嵌套的层数

嵌套层数越多,代码越复杂, 其全部的复杂度也就可能越高.因此控制嵌套层数是降低Bug发生概率的一个有效手段

1.提取方法

下面是一段代码的某部分主要逻辑,它有5层嵌套,摘除主要逻辑来看的话都有点复杂.

```java
if (ev.isPrintingKey()){//1
    if (mHardShift > 0 || ev.isShiftPressed()){//2
        if (charCode == 0){//3
            if (mHardShift == 1){
                mShiftPressing = false;
            }

            if (!ev.isShiftPressed()){
                if (mHardShift == 1){
                    mHardShift = 0;
                }
            }
        }
    }
}

```

1和2 由于是直接嵌套,可以合并

而3处理太长,不容易理解,可以提取方法

这样,主要的逻辑代码就变成:

```java
if (ev.isPrintingKey() && (mHardShift > 0 || ev.isShiftPressed())){
    processShift();
}

```

而提出来的3处理如下:

```java
private void processShift(){
    if (charCode == 0){//3
            if (mHardShift == 1){
                mShiftPressing = false;
            }

            if (!ev.isShiftPressed()){
                if (mHardShift == 1){
                    mHardShift = 0;
                }
            }
    }
}

```

这样可以通过提取方法逐步减少嵌套的层数.但是这并没有改变代码的处理逻辑.因此,代码的实际复杂度还是比较高的.

2. 提前判定

将
```java
if (list != null){
    for (int i = 0; i < list.size(); i++){
        //进行某种处理
    }
}
```
改为:

```java
if (list == null){
    return;
}

for (int i = 0;i < list.size(); i++){
    
}

```

这样修改,就不会因为嵌套而导致换行等问题.
和提取方法一样,提前判定并没有改变代码本质上的复杂度.

3. 用whild代替for

```java
public void searchOld(){
    int[] temp = new int[]{23, 42, 52, 34, 66, 32, 59};
    boolean found = false;
    int index = 0;
    for (int i = 0; i < temp.length; i++){
        if (temp[i] == 67){
            found = true;
            index = i;
            break;
        }
    }

    if (found){
        System.out.println("index = " + index);
    } else {
        System.out.println("Not Found");
    }
}

// 调整后
public void searchNew(){
    int[] temp = new int[]{23, 42, 52, 34, 66, 32, 59};
    int index = 0;
    
    while (index < temp.lengh && temp[index] != 67){
        index ++;
    }
    
    if (index < temp.length){
        System.out.println("index = " + index);
    } else {
        System.out.println("Not Found");
    }
}
```

这个是真正降低嵌套层数的做法


2. 提取全局变量

当有的参数被调用的次数过多时, 可以考虑将该参数作为全局变量来使用.例如:
```java
public class Ball{
    public void markHomeNeighbors(int x, int y, int color){
        
    }
}

```



## 分离暧昧关系

两个对象之间的关系过于暧昧和纠缠不清,就会引起代码的耦合度增高.为了降低耦合度,要尽量分离暧昧关系.

### 循环引用

Aa.b和Bb.a同时存在,不知道到底谁包含了谁,之所以发生这种情况是因为除了原本正确的A包含B的关系之外,B中的若干地方还打算调用A中的某个属性或者方法,所以就把A作为B的成员变量引入.
拆离循环引用的方法有两种:

**方法1 单例模式**

让A单例,那么B如果要调用A,就可以通过获得A的实例的方法来调用A的方法.例如A.getInstance().xxx()


**方法2 引入中间人**

a. 命令模式(事件驱动机制)

引入中间类C,当B有任何需要调用A时,通过C发送一个消息;当A有任何需要调用B的处理时,也通过C发送一个消息.

b. 调停者模式

引入中间类C,把A作为C的一个成员变量,而C作为单例模式存在.那么想要引用A时应该这样调用C.getInstance().a.xxx();这样做是因为A受到其他制约,不适合作为单例模式出现,同样,C作为一个公共调停者,不仅仅为A作容器,他也可能为其他内容作容器.在实际例子当中,对于全局的设定可能就是这样一个类.

### 间接继承

A->B->C 的继承关系: C突然要调用一个被B重载了的方法,但是并没有super.super这种调用方法,这是重载错误造成的问题,之所以C打算调用A的某个方法,而不是B中那个重载了的方法,是因为B中重载的方法的作用范围超出了C的预期,B中的方法违背的单一职责原则,所以需要修改B中的重载.如果实在无法修改B中的重载,那么可以在B中增加一个引桥callSuper()来调用C中想要调用的A的方法,然后在C中调用callSuper();遇到这种情况旺旺意味着设计上出现问题了.

## 多维度变化

在一些系统中系统会有若干个维度的变量来表示系统的状态.当这些变量组合在一起时它们所形成的各种可能性为`m*n*......`将是一个很大的网格.如果将这些组合放在同一个类中,那么对于当前条件所产生的判定条件会非常多.

例如,在一个智能设备上的输入法可能有如下组合条件
- 输入设备:软键盘,硬键盘,游戏手柄,遥控器  (4种条件)
- 语言:拼音,务必,全角英文,半角英文,数字   (5种条件)
- 键盘模式:12键,50键,QWERTY键盘        (4种条件)
- 候补模式:无,一行,多行;               (3种条件)
- 是否有输入:有,无;                   (2种条件)

那么对于这种情况, 如何才能减少耦合度,减少判定处理的复杂度呢?下面是实现方式:

```java
public abstract class AbstractKeyboard{
    public KeyMode keyMode;
}

public abstract class KeyMode{
    public Language language;
}

public abstract class Language{
    public boolean inputted;
}

public abstract class Candidate{
    
}

public class InputMethod{
    public AbstractKeyboard keyboard;
    public Candidate candidate;
}


```

在这里我们将各个维度的属性按照顺序一层包装一层.这样,当各个维度发生变化时,所产生的变化情形为 `m + n + ......`,这种方式叫做桥接模式.

## 自相似对象

一般来说, 在省,市,区这种行政单位结构,部门组织结构或者商品目录的属性结构里,每个节点都具有相似性.我们把这种节点具有相似性的结构称为自相似对象.对于自相似对象,可以采用组合者模式进行处理.

例如, 要列出一个国家的所有的城市名称,可以通过下列方式进行:

```java
public abstract calss Place{
    public List<Place> subPlaces;
    public String name;
    public int id;
    public abstract void initSubs();

    private void output(){
        System.out.println(name);
    }

    public void listAll(){
        output();
        for (Place place : subPlaces){
            subPlaces.output();
        }
    }
}

public class Country extends Place{
    public void initSubs(){
        // load province from db with county.id.
    }
}

public class Province extends Place{
    public void initSubs(){
        // load city from db with province.id.
    }
}
```

这样, 制作一个联动下拉列表框是只要指明每个框所对应的类即可,这种方法叫做组合这模式.

同样,制作一个工资公式编辑器是,可以采用自相似表达式数来完成.

```java

public class ExpressionTree{
    public Node root;
}

public class Node{
    public Node left;
    public Node right;
    public String symbol;
    public double calculator(){
        Calculable calculator = 
            CalculatorFactory.createInstance(symbol);
        return calculator.calculate(left, right);
    }
}
```
这样只要构建了二叉树结构的表达数,就可以通过上述结构针对每个员工来计算工资了.




# 6. 其他
## 6.1. 随机提供器

当使用随机的时候一种方法是`Utils.randomWeight()`
另外一种提交推荐的方式是自定义业务相关接口和类

```java

/**
 * 提供随机概率
 * 
 * @author iTerminator
 */
public interface GemRandomRateProvider {
	/**
	 * 提炼2个道具相同的概率
	 */
	int rate2();

	/**
	 * 提炼3个道具相同的概率
	 */
	int rate3();

	/**
	 * 设置2个和3个相同道具的概率
	 * 
	 * @param r2
	 * @param r3
	 */
	public void rate(int r2, int r3);
}
```


```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class RandomGems {
	private int gem1;
	private int gem2;
	private int gem3;

	public RandomGems() {
	}

	public RandomGems(int gem1, int gem2, int gem3) {
		this.gem1 = gem1;
		this.gem2 = gem2;
		this.gem3 = gem3;
	}

	public int getGem1() {
		return gem1;
	}

	public void setGem1(int gem1) {
		this.gem1 = gem1;
	}

	public int getGem2() {
		return gem2;
	}

	public void setGem2(int gem2) {
		this.gem2 = gem2;
	}

	public int getGem3() {
		return gem3;
	}

	public void setGem3(int gem3) {
		this.gem3 = gem3;
	}

	public void addGem(int itemId) {
		if (gem1 == 0) {
			gem1 = itemId;
		} else if (gem2 == 0) {
			gem2 = itemId;
		} else if (gem3 == 0) {
			gem3 = itemId;
		}
	}

	public int getSameItemId() {
		if (gem1 == gem2 || gem1 == gem3) {
			return gem1;
		}
		if (gem2 == gem3) {
			return gem2;
		}
		return 0;
	}

	public boolean isTwoPair() {
		return gem1 == gem2 || gem1 == gem3 || gem2 == gem3;
	}

	public boolean isThreePair() {
		return gem1 == gem2 && gem1 == gem3;
	}

	public boolean isFull() {
		return gem1 != 0 && gem2 != 0 && gem3 != 0;
	}

	/**
	 * 是否存在宝石
	 * 
	 * @param itemId
	 * @return
	 */
	public boolean hasGem(int itemId) {
		return gem1 == itemId || gem2 == itemId || gem3 == itemId;
	}

	public void random() {
		List<Integer> allGems = new ArrayList<Integer>(Arrays.asList(gem1, gem2, gem3));
		Collections.shuffle(allGems);
		gem1 = allGems.get(0);
		gem2 = allGems.get(1);
		gem3 = allGems.get(2);
	}

	@Override
	public String toString() {
		return gem1 + " " + gem2 + " " + gem3;
	}

}

```

## 在旧代码基础上扩展类似功能

- 利用接口的思想


比如已有一个ABuff类,现需要增加另一种BBuff的类型,这样可以定义一个IBuff接口,让ABuff和BBuff都实现它



之后把接口当做一个参数, 传入之前调用的方法 内, 达到没有修改原来代码的目的
