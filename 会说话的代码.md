<!-- TOC -->

- [前言](#前言)
- [第一章 劣质代码带来的劣质体验](#第一章-劣质代码带来的劣质体验)
    - [命名类问题](#命名类问题)
        - [没有考虑调用时的情形](#没有考虑调用时的情形)
        - [命名用词不当](#命名用词不当)
        - [否定式命名](#否定式命名)
    - [结构类问题](#结构类问题)
        - [switch-case 引起的长分支](#switch-case-引起的长分支)
        - [莫名其妙的default](#莫名其妙的default)
        - [不必要的Guard代码](#不必要的guard代码)
        - [嵌套过深](#嵌套过深)
- [第二章 劣质代码是怎么产生的](#第二章-劣质代码是怎么产生的)
    - [定式思维](#定式思维)
    - [认为状态只有采用整数定义](#认为状态只有采用整数定义)
    - [对设计方法不了解](#对设计方法不了解)
    - [编程习惯不佳](#编程习惯不佳)
        - [没有管理好代码的职责](#没有管理好代码的职责)

<!-- /TOC -->
# 前言

比较糟糕的代码的写法比如:

```java
scene.find(hero, enemy, Kongfu.FIST);//都不知道谁打了谁
```

普通方式书写的代码:

```java
hero.fight(enemey, Kongfu.FIST);//知道代码的意思,但是阅读体验还不够好
```

而自表达的方式书写的代码如

```java
hero.fight(enemy).with("FIST)";//如果不看那些符号,读起来就是一句话
```

-----------


# 第一章 劣质代码带来的劣质体验

在阅读书写不够精良的代码时,读者的行为基本能够反映出代码存在的问题:

- 一直滚动鼠标滚轮 -- 方法过长
- 总是全局搜索 -- 方法过长
- 反复地查看方法实现 -- 命名无法反映其真实含义
- 不停地查看调用方法实现 -- 调用层数太多
- 画流程图 -- 嵌套太深

> 嗯 理解框架的时候, 遇到了某些方法难于理解的时候, 不妨往上面思考, 是本身你的能力不足以理解还是它本身写的就有问题.

## 命名类问题

### 没有考虑调用时的情形

如果要建立一个班级(Grade)类,那么获得学生数量该用下面哪种命名呢?

```java
//不理想的实现
grade.getStudentsCount(); // 这个get有些多余
grade.countStudents(); // 这是一个行为,给人一种"需要时间"计算出来的感受
grade.students.size(); // 这样比较不容易理解, 但是书写最简单,图省事而直接把students属性公开并不是一种好的做法
grade.size(); // 有被误解为"班级的房间大小"的可能

//完美地实现
grade.studentsCount(); // 能够最直接地反映这个要求

```

### 命名用词不当

- research 不能表示重新检索, 应该用searchAgain
- limit 表示极限而不是限制, restriction或者constraint才表示限制
- fasten 表示固定而不是加速, 应该用accelerate

> 英语没学好....

### 否定式命名

有个变量`hardKeyboardHidden`表示没有接入硬键盘.那么,在判定软键盘是否显示时,条件判定式写成这样:

```java
if (hardKeyboardHidden == 0) return false;
```

估计读起来得费上一会儿功夫才能够理解吧
```java
if (hardKeyboard.isConnected())
```
就没有那么多疑惑了
当然,这需要整体框架的调整才能够实现.


## 结构类问题

### switch-case 引起的长分支

```java
    public boolean onKeyDown(int keyCode, KeyEvent event){
        switch (keyCode){
            case KeyEvent.KEYCODE_ENTER :
                break;
            case KeyEvent.KEYCODE_SPACE :
                break;
            case KeyEvent.KEYCODE_LEFT :
                break;
            case KeyEvent.KEYCODE_RIGHT :
                break;
            case KeyEvent.KEYCODE_UP :
                break;
            case KeyEvent.KEYCODE_DOWN :
                break;
            case KeyEvent.KEYCODE_BUTTON_1 :
                break;
            case KeyEvent.KEYCODE_BUTTON_2 :
                break;
            case KeyEvent.KEYCODE_BUTTON_3 :
                break;
            case KeyEvent.KEYCODE_BUTTON_4 :
                break;
            ......

            return false;

        }
    }

```

其实这些案件都有一定的规律可循,如果按照规律来换分按键的话,代码就会简练得多.

```java
    public boolean onKeyDown(int keyCode, KeyEvent event){
        if (event.isPrintintKey()){
            return appendInput(keyCode);
        }else if (isArrowKey(keyCode)){
            return moveCursor(keyCode);
        }else if (isChannelKey(keyCode)){
            return appendInput(convertChannelToNumber(keyCode));
        }else  if (isFunctionKey(keyCode)){
            return processFuntionalKey(keyCode);
        }
        
        return false;
    }

```

这样,通过简化上层处理,把各种处理逻辑分散到各个小的方法中完成,对可读性的改善效果是很明显的.

### 莫名其妙的default

在switch-case中,default语句代表没有被列出的case的处理.但是对于有限取值范围的情形,在列出所有的case之后,还有多列一个超出取值范围的default.遇到这种情况的程序员由于无法确定default应该怎么处理,一般采取直接return返回.但是对于需要返回值的方法来说,return 0;或者return false;都是可能引发错误的处理方式.

```java
   public enum State{
        CREATED, UPDATED, DELETED;
    }
    
    public void process(State state){
        switch (state){
            case CREATED:
                break;
            case UPDATED:
                break;
            case DELETED:
                break;
            default://这个分支永远不会发生
                break;
        }
    }

```

这种情况可以利用多态方式来处理,下面的例子采用了枚举,也可以用接口派生的方法.

```java
   public enum State{
        CREATED{
            public void process(){
                
            }
        },
        UPDATED{
            public void process(){

            }
        },
        DELETED{
            public void process(){

            }
        };

    } 
    
    public void process(State state){
        state.process();
    }

```
这样由于State的取值范围有限,不会出现其他情况.所以,就不必考虑default的情形了.



### 不必要的Guard代码

一般来说,为了防止传入的参数是null, 采取Guard代码防止NullPointException异常发生是一种常见的做法.但是如果可以确保传入的参数不是null,则没必要进行校验.对于长度的校验也是一样的.

```java

public void process(Object object){
    if (object == nul){
        return;
    }

    //process......
}
```

上面的代码可以简化为下面这样来避免使用null判定:

```java
Object object = ObjectFactory.create();
process(object);
```

在工厂类ObjectFatory中确保object不为null;

> 概括起来就是调用的上层已经做好处理,下层直接用就好,不需要考虑其他德尔条件, 不增加负担

### 嵌套过深

```java

    public void render(){
        for (int i = 0; i < MAX_ROW; i++) {
            for (int j = 0; j < MAX_COLUM; j++) {
                if (balls[i][j].state != DESTROYED){
                    if (balls[i][j].state == SELECTED){
                        Color color = getLightColor(balls[i][j].color);
                        display(i, j, color);
                    } else {
                        Color color = getColor(balls[i][j].color);
                        display(i, j, color);
                    }
                }
            }
        }
    } 

```

当代码嵌套这么深时,理解代码就变得不容易了.对于上述例子如果把balls的二维数组改成一维数组,然后把状态作为Ball类的一个属性,嵌套就会一下子减少很多层.例如

```java
    public void process(){
        for (Ball ball : balls){
            ball.render();
        }
    }
    
    public class Ball{
        public int x;
        public int y;
        public State state;
        public Color lightColor;
        public Color darkColor;
        public void render(){
            state.render(this);
        }
        
        public enum State{
            DESTROYED{
              public void render(Ball ball){
                  
              }  
            },
            SELECTED{
                public void render(Ball ball){
                    display(ball.x, ball.y, ball.lightColor);
                }
            },
            NORMAL{
                public void render(Ball ball){
                    display(ball.x, ball.y, ball.darkColor);
                }
            };
            
            public void render(Ball ball){
                
            }
        }
    }

```


# 第二章 劣质代码是怎么产生的


## 定式思维

例如,格斗游戏中, 单击`轻拳`按钮,在不同的情况下所展示的图像会不同.一般会倾向于按照这种结构来实现代码.

```java
public class Warrior{
    public void fight(){
        if (条件1){
            //处理1
        } else if (条件2){
            //处理2
        } else if (条件3){
            //处理3
        }
        
    }
}
 
 
```

但是,对于这种情况来说,将`轻拳`采用多态来处理,根据情况通过Factory创建不同的`轻拳`对象,从而进行攻击处理的话,代码就变得更为易读,易懂且容易扩展了.

```java

    public class Warrior{
        public Attackable fist;
        public void fight(){
            FistFactory.create().attack();
        }
    }
    
    public interface Attackable{
        public void attack();
    } 
    
    publicic class LightFist implements Attackable{

        @Override
        public void attack() {
            //处理1
        }
    }

    publicic class SuperLightFist implements Attackable{

        @Override
        public void attack() {
            //处理2
        }
    }

    publicic class LiteFist implements Attackable{

        @Override
        public void attack() {
            //处理3
        }
    }
    
    public class FistFactory{
        public static Attackable create(){
            if (条件1){
                return new LightFist();
            }else if (条件2){
                return new SuperLightFist();
            }else if (条件3){
                return new LightFist();
            }
            return null;
        }
    }
```

当需要增加一个新的攻击方式时,只要对上述Attackable接口进行实现,并且FistFactory类中进行注册即可.而从阅读上来说,上层代码并不需要关心当前的是哪个攻击对象,只要调用其方法attack即可.

## 认为状态只有采用整数定义

例如,下面的例子中,1代表刚注册, 2代表已经申请成功,3代表其他状态,那么在申请时的处理如下:

```java

public void apply(){
        if (state == 1){
            state = 2;
            message = "申请成功.";
        } else if (state == 2){
            message = "你已经申请过了.";
        } else {
            message = "你还没有资格申请.";
        }
    }
```

这样的代码,即使把魔法数字变为常量,对改良可读性的帮助也是有限的.但是,如果采用状态模式来处理,就会变得简单,并且具有更好的可扩展性.

```java

   public interface State{
        public State apply() throws BusinessException;
    }
    
    public class Registered implements State{

        @Override
        public State apply() throws BusinessException {
            return new Applied();
        }
    }

    public class Applied implements State{

        @Override
        public State apply() throws BusinessException {
            return new BusinessException("你已经申请过了.");
        }
    }

    public class Passed implements State{

        @Override
        public State apply() throws BusinessException {
            return new BusinessException("你还没有资格申请.");
        }
    }
    
    public void apply(){
        try {
            state = state.apply();
        } catch (BusinessException e){
            showMessage(e.getMessage());
        }
    }
```

## 对设计方法不了解

由于任务划分等管理方面的原因,程序员被定位为依照别人的设计进行代码加工的"码农",以至于程序员很少能够思考设计方面的事情,只是机械的堆砌代码.在这样 的任务分配模式下,程序员的能力得不到提升,也就不知道更多好的设计方法,而对设计方法的不了解会造成很多代码上的问题.

下面是一些常见的对于设计方法不了解而造成的问题: 
- 重复与类似
- 包结构不清晰
- 类责任不明确
- 常量数据类
- 长方法
- 复杂分支
- 类膨胀
- 类爆炸

不了解设计方法会在一个简单的问题上耗费大量的时间,有时会把一个简单的问题复杂化,有时会重复实现已有完整解决方案的代码,有时则会埋下bug隐患.

> 那么问题来了, 框架的设计方法该如何了解透彻,从何入手?

## 编程习惯不佳

### 没有管理好代码的职责

比如在一个等级用户信息的应用程序中需要进行电子邮件的校验,那么对于电子邮件校验的代码,如果不注意就会直接放在UI代码中.然而,这个电子邮件的校验程序可能在别的地方调用,那么就无法访问这个方法了.为了提高可重用性,可以把这个方法放在Util类里面,放在Util类里的调用情形是这样的:

```java
Util.isEmail(user.email);
```

这仍然不够好,因为在上面的代码中, email是String 类型.当需要发送电子邮件时需要将电子邮件地址携程"姓名"<邮件地址>的形式.单纯的String
类型不能满足要求.也就是说, 需要一个EmailAddress类来存储与电子邮件地址相关的数据.

```java

public class EmailAddress{
    String address;
    String name;
}

```

我们可以得出结论: 电子邮件的格式校验应该放在电子邮件类中实现.

```java

public class EmailAddress{
    String address;
    String name;

    public boolean verify(){
        //方法体略.
    }
}
```

这个例子说明了随手放置方法功能会导致代码可复用性降低,职责混乱等问题.


