<!-- TOC -->

- [前言](#前言)
- [第一章 劣质代码带来的劣质体验](#第一章-劣质代码带来的劣质体验)
    - [命名类问题](#命名类问题)
        - [没有考虑调用时的情形](#没有考虑调用时的情形)
        - [命名用词不当](#命名用词不当)
        - [否定式命名](#否定式命名)
    - [结构类问题](#结构类问题)
        - [switch-case 引起的长分支](#switch-case-引起的长分支)
        - [莫名其妙的default](#莫名其妙的default)
        - [不必要的Guard代码](#不必要的guard代码)
        - [嵌套过深](#嵌套过深)
- [第二章 劣质代码是怎么产生的](#第二章-劣质代码是怎么产生的)
    - [定式思维](#定式思维)
    - [认为状态只有采用整数定义](#认为状态只有采用整数定义)
    - [对设计方法不了解](#对设计方法不了解)
    - [编程习惯不佳](#编程习惯不佳)
        - [没有管理好代码的职责](#没有管理好代码的职责)
- [第六章 编程语言的学习](#第六章-编程语言的学习)
    - [简化的校验模型](#简化的校验模型)
    - [简化的权限模型](#简化的权限模型)
    - [设计模式](#设计模式)
    - [采用位掩码减少类的个数](#采用位掩码减少类的个数)
        - [位掩码](#位掩码)

<!-- /TOC -->
# 前言

比较糟糕的代码的写法比如:

```java
scene.find(hero, enemy, Kongfu.FIST);//都不知道谁打了谁
```

普通方式书写的代码:

```java
hero.fight(enemey, Kongfu.FIST);//知道代码的意思,但是阅读体验还不够好
```

而自表达的方式书写的代码如

```java
hero.fight(enemy).with("FIST)";//如果不看那些符号,读起来就是一句话
```

-----------


# 第一章 劣质代码带来的劣质体验

在阅读书写不够精良的代码时,读者的行为基本能够反映出代码存在的问题:

- 一直滚动鼠标滚轮 -- 方法过长
- 总是全局搜索 -- 方法过长
- 反复地查看方法实现 -- 命名无法反映其真实含义
- 不停地查看调用方法实现 -- 调用层数太多
- 画流程图 -- 嵌套太深

> 嗯 理解框架的时候, 遇到了某些方法难于理解的时候, 不妨往上面思考, 是本身你的能力不足以理解还是它本身写的就有问题.

## 命名类问题

### 没有考虑调用时的情形

如果要建立一个班级(Grade)类,那么获得学生数量该用下面哪种命名呢?

```java
//不理想的实现
grade.getStudentsCount(); // 这个get有些多余
grade.countStudents(); // 这是一个行为,给人一种"需要时间"计算出来的感受
grade.students.size(); // 这样比较不容易理解, 但是书写最简单,图省事而直接把students属性公开并不是一种好的做法
grade.size(); // 有被误解为"班级的房间大小"的可能

//完美地实现
grade.studentsCount(); // 能够最直接地反映这个要求

```

### 命名用词不当

- research 不能表示重新检索, 应该用searchAgain
- limit 表示极限而不是限制, restriction或者constraint才表示限制
- fasten 表示固定而不是加速, 应该用accelerate

> 英语没学好....

### 否定式命名

有个变量`hardKeyboardHidden`表示没有接入硬键盘.那么,在判定软键盘是否显示时,条件判定式写成这样:

```java
if (hardKeyboardHidden == 0) return false;
```

估计读起来得费上一会儿功夫才能够理解吧
```java
if (hardKeyboard.isConnected())
```
就没有那么多疑惑了
当然,这需要整体框架的调整才能够实现.


## 结构类问题

### switch-case 引起的长分支

```java
    public boolean onKeyDown(int keyCode, KeyEvent event){
        switch (keyCode){
            case KeyEvent.KEYCODE_ENTER :
                break;
            case KeyEvent.KEYCODE_SPACE :
                break;
            case KeyEvent.KEYCODE_LEFT :
                break;
            case KeyEvent.KEYCODE_RIGHT :
                break;
            case KeyEvent.KEYCODE_UP :
                break;
            case KeyEvent.KEYCODE_DOWN :
                break;
            case KeyEvent.KEYCODE_BUTTON_1 :
                break;
            case KeyEvent.KEYCODE_BUTTON_2 :
                break;
            case KeyEvent.KEYCODE_BUTTON_3 :
                break;
            case KeyEvent.KEYCODE_BUTTON_4 :
                break;
            ......

            return false;

        }
    }

```

其实这些案件都有一定的规律可循,如果按照规律来换分按键的话,代码就会简练得多.

```java
    public boolean onKeyDown(int keyCode, KeyEvent event){
        if (event.isPrintintKey()){
            return appendInput(keyCode);
        }else if (isArrowKey(keyCode)){
            return moveCursor(keyCode);
        }else if (isChannelKey(keyCode)){
            return appendInput(convertChannelToNumber(keyCode));
        }else  if (isFunctionKey(keyCode)){
            return processFuntionalKey(keyCode);
        }
        
        return false;
    }

```

这样,通过简化上层处理,把各种处理逻辑分散到各个小的方法中完成,对可读性的改善效果是很明显的.

### 莫名其妙的default

在switch-case中,default语句代表没有被列出的case的处理.但是对于有限取值范围的情形,在列出所有的case之后,还有多列一个超出取值范围的default.遇到这种情况的程序员由于无法确定default应该怎么处理,一般采取直接return返回.但是对于需要返回值的方法来说,return 0;或者return false;都是可能引发错误的处理方式.

```java
   public enum State{
        CREATED, UPDATED, DELETED;
    }
    
    public void process(State state){
        switch (state){
            case CREATED:
                break;
            case UPDATED:
                break;
            case DELETED:
                break;
            default://这个分支永远不会发生
                break;
        }
    }

```

这种情况可以利用多态方式来处理,下面的例子采用了枚举,也可以用接口派生的方法.

```java
   public enum State{
        CREATED{
            public void process(){
                
            }
        },
        UPDATED{
            public void process(){

            }
        },
        DELETED{
            public void process(){

            }
        };

    } 
    
    public void process(State state){
        state.process();
    }

```
这样由于State的取值范围有限,不会出现其他情况.所以,就不必考虑default的情形了.



### 不必要的Guard代码

一般来说,为了防止传入的参数是null, 采取Guard代码防止NullPointException异常发生是一种常见的做法.但是如果可以确保传入的参数不是null,则没必要进行校验.对于长度的校验也是一样的.

```java

public void process(Object object){
    if (object == nul){
        return;
    }

    //process......
}
```

上面的代码可以简化为下面这样来避免使用null判定:

```java
Object object = ObjectFactory.create();
process(object);
```

在工厂类ObjectFatory中确保object不为null;

> 概括起来就是调用的上层已经做好处理,下层直接用就好,不需要考虑其他德尔条件, 不增加负担

### 嵌套过深

```java

    public void render(){
        for (int i = 0; i < MAX_ROW; i++) {
            for (int j = 0; j < MAX_COLUM; j++) {
                if (balls[i][j].state != DESTROYED){
                    if (balls[i][j].state == SELECTED){
                        Color color = getLightColor(balls[i][j].color);
                        display(i, j, color);
                    } else {
                        Color color = getColor(balls[i][j].color);
                        display(i, j, color);
                    }
                }
            }
        }
    } 

```

当代码嵌套这么深时,理解代码就变得不容易了.对于上述例子如果把balls的二维数组改成一维数组,然后把状态作为Ball类的一个属性,嵌套就会一下子减少很多层.例如

```java
    public void process(){
        for (Ball ball : balls){
            ball.render();
        }
    }
    
    public class Ball{
        public int x;
        public int y;
        public State state;
        public Color lightColor;
        public Color darkColor;
        public void render(){
            state.render(this);
        }
        
        public enum State{
            DESTROYED{
              public void render(Ball ball){
                  
              }  
            },
            SELECTED{
                public void render(Ball ball){
                    display(ball.x, ball.y, ball.lightColor);
                }
            },
            NORMAL{
                public void render(Ball ball){
                    display(ball.x, ball.y, ball.darkColor);
                }
            };
            
            public void render(Ball ball){
                
            }
        }
    }

```


# 第二章 劣质代码是怎么产生的


## 定式思维

例如,格斗游戏中, 单击`轻拳`按钮,在不同的情况下所展示的图像会不同.一般会倾向于按照这种结构来实现代码.

```java
public class Warrior{
    public void fight(){
        if (条件1){
            //处理1
        } else if (条件2){
            //处理2
        } else if (条件3){
            //处理3
        }
        
    }
}
 
 
```

但是,对于这种情况来说,将`轻拳`采用多态来处理,根据情况通过Factory创建不同的`轻拳`对象,从而进行攻击处理的话,代码就变得更为易读,易懂且容易扩展了.

```java

    public class Warrior{
        public Attackable fist;
        public void fight(){
            FistFactory.create().attack();
        }
    }
    
    public interface Attackable{
        public void attack();
    } 
    
    publicic class LightFist implements Attackable{

        @Override
        public void attack() {
            //处理1
        }
    }

    publicic class SuperLightFist implements Attackable{

        @Override
        public void attack() {
            //处理2
        }
    }

    publicic class LiteFist implements Attackable{

        @Override
        public void attack() {
            //处理3
        }
    }
    
    public class FistFactory{
        public static Attackable create(){
            if (条件1){
                return new LightFist();
            }else if (条件2){
                return new SuperLightFist();
            }else if (条件3){
                return new LightFist();
            }
            return null;
        }
    }
```

当需要增加一个新的攻击方式时,只要对上述Attackable接口进行实现,并且FistFactory类中进行注册即可.而从阅读上来说,上层代码并不需要关心当前的是哪个攻击对象,只要调用其方法attack即可.

## 认为状态只有采用整数定义

例如,下面的例子中,1代表刚注册, 2代表已经申请成功,3代表其他状态,那么在申请时的处理如下:

```java

public void apply(){
        if (state == 1){
            state = 2;
            message = "申请成功.";
        } else if (state == 2){
            message = "你已经申请过了.";
        } else {
            message = "你还没有资格申请.";
        }
    }
```

这样的代码,即使把魔法数字变为常量,对改良可读性的帮助也是有限的.但是,如果采用状态模式来处理,就会变得简单,并且具有更好的可扩展性.

```java

   public interface State{
        public State apply() throws BusinessException;
    }
    
    public class Registered implements State{

        @Override
        public State apply() throws BusinessException {
            return new Applied();
        }
    }

    public class Applied implements State{

        @Override
        public State apply() throws BusinessException {
            return new BusinessException("你已经申请过了.");
        }
    }

    public class Passed implements State{

        @Override
        public State apply() throws BusinessException {
            return new BusinessException("你还没有资格申请.");
        }
    }
    
    public void apply(){
        try {
            state = state.apply();
        } catch (BusinessException e){
            showMessage(e.getMessage());
        }
    }
```

## 对设计方法不了解

由于任务划分等管理方面的原因,程序员被定位为依照别人的设计进行代码加工的"码农",以至于程序员很少能够思考设计方面的事情,只是机械的堆砌代码.在这样 的任务分配模式下,程序员的能力得不到提升,也就不知道更多好的设计方法,而对设计方法的不了解会造成很多代码上的问题.

下面是一些常见的对于设计方法不了解而造成的问题: 
- 重复与类似
- 包结构不清晰
- 类责任不明确
- 常量数据类
- 长方法
- 复杂分支
- 类膨胀
- 类爆炸

不了解设计方法会在一个简单的问题上耗费大量的时间,有时会把一个简单的问题复杂化,有时会重复实现已有完整解决方案的代码,有时则会埋下bug隐患.

> 那么问题来了, 框架的设计方法该如何了解透彻,从何入手?

## 编程习惯不佳

### 没有管理好代码的职责

比如在一个等级用户信息的应用程序中需要进行电子邮件的校验,那么对于电子邮件校验的代码,如果不注意就会直接放在UI代码中.然而,这个电子邮件的校验程序可能在别的地方调用,那么就无法访问这个方法了.为了提高可重用性,可以把这个方法放在Util类里面,放在Util类里的调用情形是这样的:

```java
Util.isEmail(user.email);
```

这仍然不够好,因为在上面的代码中, email是String 类型.当需要发送电子邮件时需要将电子邮件地址携程"姓名"<邮件地址>的形式.单纯的String
类型不能满足要求.也就是说, 需要一个EmailAddress类来存储与电子邮件地址相关的数据.

```java

public class EmailAddress{
    String address;
    String name;
}

```

我们可以得出结论: 电子邮件的格式校验应该放在电子邮件类中实现.

```java

public class EmailAddress{
    String address;
    String name;

    public boolean verify(){
        //方法体略.
    }
}
```

这个例子说明了随手放置方法功能会导致代码可复用性降低,职责混乱等问题.


# 第六章 编程语言的学习

## 简化的校验模型

当从外部输入传来输入时要对响应的数据进行校验才能够使用.但是传统方法把所有参数都进行全面校验,光校验代码就会占据一半个方法的长度.下面是一个图书信息保存的例子:

```java

    public  class BookAction{
        public void save(Book book) throws ValidationError{
            if (book.name == null || book.name.equals("")){
                throw new ValidationError("书名不能为空.");
            }
            if (book.isbn == null || book.isbn.equals("")){
                throw new ValidationError("ISBN不能为空.");
            }
            if (book.press == null || book.press.equals("")){
                throw new ValidationError("出版社不能为空.");
            }
            if (book.author == null || book.author.equals("")){
                throw new ValidationError("作者不能为空.");
            }
            
            book.save();
        }
    }
```

为了更加明确代码的含义,附上Book类的定义和ValidationException类的定义

```java
    public class Book{
        public String name;
        public String author;
        public String press;
        public String isbn;
        
    }
    
    public class ValidationError implements Throwable{
        public String mMessage;
        public ValidationError(String message){
            mMessage = message;
        }
    }

```

就上述代码来说,大量的校验代码使得阅读体验大大下降.
有一种相对简单的修改方式就是将非空判定提取到Util类中完成.

例如

```java
public class StringUtil{
        public static boolean isNullOrEmpty(String text){
            return text == null || text.equals("");
        }
    }
```
但是这并不能够缩减长长的判定语句,而且如果增加了长度校验,类型校验(例如ISBN号只能是数字和短线,并符合一定规则)等,校验代码将仍然会变长

如果采用这种形式来书写,代码的可读性就一定能大大提高
```java
    public class BookAction{
        public void save(Book book){
            List<ValidateError> errors = validate(book);
            if (!errors.isEmpty()){
                render(errors);
                return;
            }
            book.save();
        }
        
        private List<ValidateError> validate(Entity entity){
            //这里究竟该怎么写呢?后面再来分析
        }
        
        private void render(List<ValidateError> errors){
            //将各种错误消息显示在正确的位置上
        }
    }
    
    public class ValidateError{
        public String fieldName;
        public String errorText;
    }
```

如果只是把以前的校验换一种形式存放,那么并不能对整体可读性带来多大优势,而且可复用性也不强.所以,校验应该和Book类本身分开, 将来校验其他对象时也可以采用同样机制进行校验.

如果可以通过这种形式对Book进行定义,其他对象也可以采用同样方式进行定义,代码就变得易读好懂,复用性也得到了提高

```java
 public class Book extends Entity{
        @Required
        public String name;
        @Required
        public String author;
        @Required
        public String press;
        @Required
        @MaxLength(17)
        public String isbn;
    }
```

上述Annotaion的对应定义如下:
```java
    public @interface Required{

    }

    public @interface MaxLength{
        int value();
    }

```
那么怎么才能实现对应的校验呢?
限于篇幅原因,下列代码为简化校验模型,只处理String类型的数据,处理其他类型的数据则会发生错误.


```java
    public class BookAction {
        public List<ValidateError> validate(Book book) {
            List<ValidateError> errors = new ArrayList<>();
            java.lang.reflect.Field[] fields = book.getClass().getDeclaredFields();
            for (java.lang.reflect.Field field : fields) {
                Annotation[] annotaions = field.getDeclaredAnnotations();
                for (Annotation a : annotaions) {
                    if (a instanceof Required) {
                        if (ValidateUtil.isNullOrEmpty(field)) {
                            errors.add(new ValidateError(field, field.name + "不能为空."));
                        }
                    } else if (a instanceof MaxLength) {
                        if (field.length() > ((MaxLength) a).value()) {
                            errors.add(new ValidateError(field, field.name + "长度不能超过" + ((MaxLength) a).value() + "."));
                        }
                    }
                }
            }

            return errors;
        }
    }

```

这样,就可以通过Annotation来大幅度简化校验代码,并且通过一个通用的校验来进行全部的处理.还可以考虑为校验机制增加可扩展接口,为方便其他人增加自己的校验机制,例如特殊的格式校验等.

## 简化的权限模型

权限校验是一般系统中比较常见的一个功能.对于权限设计的方法也是多种多样的,而采用注解进行权限模型的设计会使实现和变更都变得很容易.

页面的权限声明方式:

```java

 public class Users extends Controller{
       @Permission(Authority.ALL)
       public String list(){}

       @Permission(Authority.ADMIN | Authority.SELF)
       public String edit(int id){}

       @Permission(Authority.ADMIN | Authority.SELF)
       public String save(int id){}
   }
```

这是一个[以位掩码的方式](#采用位掩码减少类的个数)定义的类,
而使用这些数据的方式可以通过下面的类来实现
```java
    public class Authority{
        public static final int ALL = 0xffffff;

        public static final int ROLE_MASK = 0x000fff;
        public static final int ADMIN = 0x000001;
        public static final int MANAGER = 0x000002;

        public static final int OWNER_SHIP = 0xfff000;
        public static final int SELF = 0x001000;
        public static final int OWNER = 0x002000;
    }


    public class Controller{
        public String invoke(String className, String methodName){
            Class clazz = Class.forName(className);
            Method method = clazz.getDeclaredMethod(methodName);
            Annotation permission = method.getDeclaredMethod("Permession");
            int authority = permission.value();
            int userPermission = session.get("USER_PERMISSION");
            if ((userPermission && Authority.ROLE_MASK & authority == 0)
                    && (userPermission & Authority.OWNER_SHIP & authority == 0)){
                return "no_permission";
            }
            
            return method.invoke(clazz.newInstance());
        }
    }
```

在上面的例子中,主调度方法利用各个方法定义的注解来判定其权限,这样每个方法定义其自己的权限即可.通过这样的方法把权限分散到各个方法自身去,比较容易判断定义的正确性,也利于维护,而采用集中式权限判定容易产生遗漏和错误.

# 第7章 设计方法的学习


## 设计模式

- 创建型模式:
  - 抽象工厂:创建几类家族的实例
  - 构建者:把对象的构建和它分开
  - 工厂方法:创建一个共通接口的若干个子类的实例
  - 原型:创建一个被完整初始化的实例用于复制或者克隆
  - 单例:使一个类无论在什么时候访问都可以得到唯一的实例
- 结构性模式:
  - 适配器:为多个不同的类之间建立连接的接口
  - 桥接:对象有多个属性时把属性之间的关联关系从m*n改为m+n
  - 装饰:动态的为对象增加责任
  - 外观:通过一个接口来隐藏整个子系统
  - 享元:用一个共享的实例来加快访问
  - 代理:用一个对象代表另一个对象
- 行为型模式:
  - 职责链:在一个链条间传递任务
  - 命令:把命令包装为对象
  - 翻译者:在一个语言环境中不同的语言元素表示不同的语义
  - 迭代者:循环地访问一个列表中的元素
  - 协调者:在对象之间建立一个简化的沟通类
  - 备注:存储对象内部的数值
  - 观察值:当对象发生变化时通知一组其他对象
  - 状态:当对象的状态变更时变更处理
  - 策略:采取不同的算法进行不同的处理
  - 模板方法:把通用的处理放在父类,具体的实现步骤放在子类中实现
  - 访问者:不必改变对象定义的情况下定义应用于对象的操作

## 采用位掩码减少类的个数

### 位掩码

位掩码的意思是,对于一个数字的每一位作为一个开关的标志
